### **Объяснение с примерами**

Прямое изменение состояния нарушает принципы работы React и приводит к проблемам.

---

#### **1. Прямое изменение (НЕПРАВИЛЬНО)**
```jsx
function Component() {
  const [user, setUser] = useState({ name: 'Иван', age: 25 });
  
  const handleClick = () => {
    // ❌ Прямое изменение состояния
    user.name = 'Петр'; // Изменяем существующий объект
    user.age = 30;
    
    // Компонент НЕ перерисуется!
    // React не знает, что состояние изменилось
  };
  
  return (
    <div>
      Имя: {user.name}, Возраст: {user.age}
      <button onClick={handleClick}>Изменить</button>
    </div>
  );
}
// При клике: интерфейс останется прежним, хотя объект user изменился
```

#### **2. Правильное обновление (через setState/useState)**
```jsx
function Component() {
  const [user, setUser] = useState({ name: 'Иван', age: 25 });
  
  const handleClick = () => {
    // ✅ Создаём новый объект
    setUser({
      ...user,        // Копируем старые свойства
      name: 'Петр',   // Изменяем нужные
      age: 30
    });
    
    // Компонент перерисуется с новыми данными
  };
  
  // UI обновится
}
```

---

#### **3. Что происходит под капотом**

**React использует сравнение ссылок (reference equality):**
```jsx
const prevState = { name: 'Иван', age: 25 };
const newState = prevState; // Та же ссылка

// ❌ Прямое изменение
prevState.name = 'Петр';
// prevState === newState (true) - React считает, что ничего не изменилось

// ✅ Правильное изменение
const newState = { ...prevState, name: 'Петр' };
// prevState === newState (false) - React видит изменения
```

#### **4. Проблемы с прямым изменением**
```jsx
class Counter extends React.Component {
  state = { count: 0 };
  
  increment = () => {
    // ❌ Прямое изменение
    this.state.count += 1;
    
    // 1. React не запускает ререндер
    // 2. Нарушается принцип иммутабельности
    // 3. DevTools не показывают изменения
    // 4. Оптимизации (PureComponent, React.memo) ломаются
  };
}
```

#### **5. Исключение: useRef**
```jsx
function Component() {
  const counter = useRef(0); // useRef специально создан для мутабельных значений
  
  const increment = () => {
    counter.current += 1; // ✅ Можно менять напрямую
    // Но это НЕ вызовет ререндер
  };
  
  return <div>{counter.current}</div>; // Не обновится!
}
```

---

### **Резюме**

Прямое изменение состояния запрещено, потому что React полагается на иммутабельные обновления для отслеживания изменений и оптимизации рендеринга.

**Ключевые нюансы:**
1. **Механизм сравнения:** React сравнивает **ссылки** на объекты состояния, а не их содержимое. Прямое изменение не создаёт новую ссылку.
2. **Отсутствие ререндера:** React не узнает об изменении состояния и не перерисовывает компонент.
3. **Нарушение оптимизаций:** Ломается работа `PureComponent`, `React.memo`, `shouldComponentUpdate`, которые полагаются на иммутабельные обновления.

**Выжимка по объяснению:**
React не отслеживает изменения внутри объектов/массивов, а сравнивает, изменилась ли ссылка на них. При прямом изменении состояния ссылка остаётся прежней, поэтому React считает, что ничего не изменилось, и не запускает повторный рендер. Правильный подход — всегда создавать новые объекты/массивы при обновлении состояния.