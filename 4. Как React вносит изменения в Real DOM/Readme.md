### **Объяснение с примерами**

React вносит изменения в Real DOM через процесс **реконсиляции (reconciliation)**. Этот процесс состоит из двух основных фаз: **рендер (render phase)** и **фиксация (commit phase)**.

---

#### **1. Рендер фаза (Render Phase) - Определение "что" изменилось**
На этом этапе React вычисляет разницу между предыдущим и новым состоянием интерфейса, работая **только с Virtual DOM**.

```jsx
// Пример: компонент с состоянием
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Счет: {count}</h1>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}
```

**Что происходит при клике на кнопку:**
1. Вызывается `setCount(count + 1)` → меняется состояние
2. React планирует повторный рендер компонента `Counter`
3. Вызывается функция `Counter()` для получения нового JSX
4. Создается **новое дерево Virtual DOM**:
```javascript
// Новое VDOM (после увеличения count с 0 до 1)
{
  type: 'div',
  props: {},
  children: [
    {
      type: 'h1',
      props: {},
      children: ['Счет: 1']  // Только здесь изменилось!
    },
    {
      type: 'button',
      props: { onClick: [Function] },
      children: ['Увеличить']
    }
  ]
}
```
5. React сравнивает это дерево с предыдущим через **алгоритм diffing**

**Алгоритм Diffing (сравнения):**
- React сравнивает деревья на уровне корневых элементов
- Если тип элемента изменился (`div` → `span`) — пересоздает всё поддерево
- Если тип тот же — сравнивает атрибуты и обновляет только измененные
- Для списков использует **key** для идентификации элементов

```jsx
// Без key: неэффективно при вставке в начало списка
{items.map(item => <li>{item}</li>)}

// С key: React понимает, какие элементы сохранить
{items.map(item => <li key={item.id}>{item.text}</li>)}
```

---

#### **2. Фаза фиксации (Commit Phase) - Внесение изменений в Real DOM**
Только после определения всех изменений React синхронизирует их с Real DOM.

```javascript
// Пример того, что React делает "под капотом":

// 1. Находит, что изменился textNode внутри h1
const oldText = 'Счет: 0';
const newText = 'Счет: 1';

// 2. Пакетно применяет изменения
// Вместо последовательных операций:
// document.querySelector('h1').textContent = 'Счет: 1';
// (что вызвало бы рефлоу)

// React использует эффективный подход:
// - Собирает ВСЕ изменения за один цикл событий
// - Применяет их за одну операцию
// - Минимизирует количество обращений к Real DOM API
```

**Как React применяет изменения:**

| **Тип изменения** | **React Action** | **Real DOM API (примерно)** |
|-------------------|------------------|-----------------------------|
| Изменение текста | `textContent` обновление | `textNode.nodeValue = 'новый текст'` |
| Изменение атрибута | Обновление свойства | `element.setAttribute('class', 'new-class')` |
| Добавление элемента | Вставка узла | `parent.appendChild(newNode)` |
| Удаление элемента | Удаление узла | `parent.removeChild(oldNode)` |
| Замена элемента | Замена узла | `parent.replaceChild(new, old)` |

**Батчинг (пакетная обработка):**
```jsx
// React группирует обновления
function MultipleUpdates() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  const handleClick = () => {
    setA(1);  // Не вызывает сразу ререндер
    setB(2);  // Эти обновления объединяются
  };
  // Только ОДИН рендер и ОДНО обновление DOM
}
```

---

#### **3. Фаза отрисовки браузера (Browser Paint Phase)**
После того как React обновил Real DOM, браузер:
1. Выполняет **Reflow** (пересчет геометрии элементов)
2. Выполняет **Repaint** (перерисовка пикселей)

React минимизирует и эти этапы, группируя изменения.

```jsx
// Пример с анимацией: плохой подход
function BadExample() {
  const [left, setLeft] = useState(0);
  
  useEffect(() => {
    // Множественные обновления DOM → множество рефлоуов
    for (let i = 0; i < 100; i++) {
      setLeft(i);  // 100 обновлений DOM!
    }
  }, []);
}

// Хороший подход
function GoodExample() {
  const ref = useRef();
  
  useEffect(() => {
    // Одно обновление DOM через requestAnimationFrame
    requestAnimationFrame(() => {
      ref.current.style.transform = `translateX(100px)`;
    });
  }, []);
}
```

---

### **Резюме**

React вносит изменения в Real DOM через двухфазный процесс: сначала вычисляет изменения в Virtual DOM (рендер фаза), затем пакетно применяет их к Real DOM (фаза фиксации).

**Ключевые нюансы:**
1. **Две фазы:** Render phase (вычисление изменений в VDOM) → Commit phase (применение к Real DOM). Это разделение позволяет React оптимизировать производительность.
2. **Пакетная обработка:** React группирует множественные обновления состояния в один цикл обновления DOM, минимизируя дорогостоящие операции рефлоу/репайнт.
3. **Инкрементальные обновления:** React изменяет только те части DOM, которые действительно изменились, используя алгоритм diffing и ключи (keys) для списков.

**Выжимка по объяснению:**
React не обновляет Real DOM напрямую при каждом изменении состояния. Вместо этого он сначала перерисовывает компоненты в Virtual DOM, находит различия между старым и новым VDOM через алгоритм diffing, определяя минимальный набор необходимых изменений. Затем все эти изменения собираются в "пакет" и одним эффективным обновлением применяются к реальному DOM, после чего браузер делает финальную перерисовку.

**Как сказать своими словами кратко:**
>«React работает с Real DOM как смарт-редактор: сначала он делает "черновик" изменений в Virtual DOM (в памяти), сравнивает его с предыдущей версией, выделяет только те места, где есть правки, и потом применяет эти правки к реальной странице одной операцией, а не переписывает всё заново.»