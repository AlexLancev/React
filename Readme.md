### Что такое React?

• Это JS библиотека для декларативной сборки переиспользуемых UI-компонентов на основе JSX  
• Использует Virtual DOM для эффективного обновления интерфейса  
• Отвечает только за отрисовку  
• Позволяет гибко выбирать остальные инструменты  

### Что такое Virtual DOM?

• Легковесная JS-копия реального DOM, используемая React как стратегия оптимизации  
• Вычисляет разницу между состояниями интерфейса (diffing), и определяет минимальный набор изменений  
• Пакетно обновляет только изменившиеся элементы страницы.  

### Объясните разницу между Real DOM и Virtual DOM

**Real DOM:**  
• **Медленный:** Прямые манипуляции с DOM — самые дорогие операции в браузере  
• **Обновляет весь узел:** Даже при изменении одного атрибута перерисовывается весь элемент и его дети  
• **Тяжёлый:** Сложная древовидная структура с тысячами свойств и методов  
• **Синхронный:** Изменения применяются сразу, что может блокировать основной поток  

**Virtual DOM:**  
• **Быстрый:** Работает с легковесными JavaScript-объектами в памяти  
• **Обновляет точечно:** Сравнивает состояния (diffing) и изменяет только нужные элементы  
• **Лёгкий:** Упрощённое представление DOM-структуры (только теги, атрибуты, содержимое)  
• **Оптимизированный:** Изменения накапливаются и применяются пачкой за один проход  


### Как React вносит изменения в Real DOM?

1. **Создание Virtual DOM**  
   При каждом изменении состояния React создаёт новый Virtual DOM — легковесный JavaScript-объект, представляющий структуру UI.

2. **Сравнение (Diffing Algorithm)**  
   React сравнивает новый Virtual DOM с предыдущим (реконсиляция) и вычисляет **минимальный набор изменений** — что именно добавить, удалить или обновить.

3. **Пакетное обновление (Batching)**  
   Все вычисленные изменения собираются в "пакет" и применяются к Real DOM **за одну синхронную операцию**, а не по отдельности.

4. **Оптимизированное обновление Real DOM**  
   React использует оптимальные браузерные API (`appendChild`, `removeChild`, `setAttribute`) только для тех узлов, которые действительно изменились.

### Что такое JSX?

• JSX (JavaScript XML) — это синтаксическое расширение для JavaScript  
• Позволяет писать декларативную разметку, похожую на HTML, внутри JS-кода.  
• На этапе сборки (например, с помощью Babel) JSX компилируется в вызовы React.createElement()  

Правила:  
• Атрибуты используют camelCase (className, onClick)  
• Можно встраивать JavaScript-выражения через { }  
• Теги обязательно закрывающиеся  

### Что такое компоненты. Какие типы компонентов вы знаете?

 Это независимый, переиспользуемый блок пользовательского интерфейса со своей структурой (разметка), стилями и логикой.

**Основные типы компонентов:**

 1.  **По синтаксису:**  
    • **Функциональные компоненты** — современный стандарт, используют хуки.  
      `const Button = () => <button>Click</button>;`  
    • **Классовые компоненты** — legacy-подход, основанный на ES6-классах.  
      `class Button extends React.Component { ... }`  

2.  **По наличию внутреннего состояния:**  
    • **Stateful (с состоянием)** — управляют своими данными через `useState`, `useReducer` или `this.state`.  
    • **Stateless (без состояния, «чистые»)** — получают данные только через `props` и всегда отрисовывают одинаковый результат для одинаковых пропсов.  

3.  **По источнику данных для форм и элементов:**  
    • **Управляемые (Controlled)** — значение элемента (например, `input`) полностью контролируется React-состоянием и передаётся через `props`. Любое изменение идёт через обработчик (например, `onChange`).  
    • **Неуправляемые (Uncontrolled)** — значение элемента хранится в самом DOM, а React получает к нему доступ через `ref` (например, при отправке формы).  

### Разница между классовыми и функциональными компонентами?

• И классовые, и функциональные компоненты могут иметь состояние, используют разный синтаксис: классы — this.state/setState(), функции — хук useState(),

• с 2019 года React рекомендует функциональные компоненты как стандарт благодаря более простой работе с побочными эффектами, переиспользуемой логикой и отсутствию проблем с this.

### Что такое props и как они передаются в компоненты?

Это объект с любым типом данных, который передаётся только дочернему компоненту через атрибуты в JSX.  

Ключевые особенности:  
• Можно типизировать через PropTypes или TS.  
• Всегда иммутабельны — изменять props внутри компонента нельзя.  
• children существует только при передаче содержимого между тегами компонента.  

### Что такое состояние (state) и чем оно отличается от props?

• **state** — это локальные изменяемые данные компонента, управляемые им самим. Обновление state вызывает ререндер компонента. State может «всплывать».  
• **props** — это внешние неизменяемые данные, передаваемые от родителя. Изменение props у родителя — ререндер дочернего компонента.  


### Жизненный цикл компонента?

Содержит три фазы:  
• монтирование (добавление в DOM);  
• обновление (из-за изменений props/state);  
• размонтирование (удаление из DOM);  

В классовых компонентах React вызывает специальные методы на каждой фазе (componentDidMount, componentDidUpdate, componentWillUnmount).  

В функциональных компонентах реализуют через хук useEffect с разными зависимостями и cleanup-функцией.

useEffect:  
- `useEffect(() => {}, [])` — только монтирование.  
- `useEffect(() => {})` — монтирование + каждое обновление.  
- `useEffect(() => {}, [deps])` — монтирование + обновление при изменении deps.  
-  `useEffect(() => { return () => {} })` Функция очистки (cleanup) выполняется перед удалением компонента (размонтирование) или перед следующим выполнением эффекта. Аналог componentWillUnmount.

###  Что такое key. Зачем они нужны при рендере списков?

Уникальный идентификатор, сопоставляет элементы списков между рендерами, позволяя обновлять только изменённые элементы.

### Что такое хуки. Какие основные правила их использования?

Хуки — это специальные функции, которые дают функциональным компонентам доступ к состоянию, побочным эффектам, контексту и другим возможностям React.

Основные правила:
1. Вызывать только на верхнем уровне компонента (не в условиях/циклах).
2. Вызывать только из React-компонентов или кастомных хуков.
3. Сохранять одинаковый порядок вызовов при каждом рендере — это позволяет React корректно сопоставлять состояние между рендерами.


### Расскажите про useState?

`useState` — это хук, который объявляет переменную состояния в функциональном компоненте.

Принимает начальное значение и возвращает массив из двух элементов:
- текущее значение состояния;
- функция-сеттер для его обновления.

При вызове функции компонент перерисовывается с новым значением.

React использует `Object.is()` для сравнения нового значения с предыдущим. Если они равны — ререндер не происходит.