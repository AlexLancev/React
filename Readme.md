## Общие вопросы

### Что такое React?

• Это JS библиотека для декларативной сборки переиспользуемых UI-компонентов на основе JSX  
• Использует Virtual DOM для эффективного обновления интерфейса  
• Отвечает только за отрисовку  
• Позволяет гибко выбирать остальные инструменты  

### Что такое Virtual DOM?

• Легковесная JS-копия реального DOM, используемая React как стратегия оптимизации  
• Вычисляет разницу между состояниями интерфейса (diffing), и определяет минимальный набор изменений  
• Пакетно обновляет только изменившиеся элементы страницы.  

### Объясните разницу между Real DOM и Virtual DOM

**Real DOM:**  
• **Медленный:** Прямые манипуляции с DOM — самые дорогие операции в браузере  
• **Обновляет весь узел:** Даже при изменении одного атрибута перерисовывается весь элемент и его дети  
• **Тяжёлый:** Сложная древовидная структура с тысячами свойств и методов  
• **Синхронный:** Изменения применяются сразу, что может блокировать основной поток  

**Virtual DOM:**  
• **Быстрый:** Работает с легковесными JavaScript-объектами в памяти  
• **Обновляет точечно:** Сравнивает состояния (diffing) и изменяет только нужные элементы  
• **Лёгкий:** Упрощённое представление DOM-структуры (только теги, атрибуты, содержимое)  
• **Оптимизированный:** Изменения накапливаются и применяются пачкой за один проход  


### Как React вносит изменения в Real DOM?

1. **Создание Virtual DOM**  
   При каждом изменении состояния React создаёт новый Virtual DOM — легковесный JavaScript-объект, представляющий структуру UI.

2. **Сравнение (Diffing Algorithm)**  
   React сравнивает новый Virtual DOM с предыдущим (реконсиляция) и вычисляет **минимальный набор изменений** — что именно добавить, удалить или обновить.

3. **Пакетное обновление (Batching)**  
   Все вычисленные изменения собираются в "пакет" и применяются к Real DOM **за одну синхронную операцию**, а не по отдельности.

4. **Оптимизированное обновление Real DOM**  
   React использует оптимальные браузерные API (`appendChild`, `removeChild`, `setAttribute`) только для тех узлов, которые действительно изменились.

### Что такое JSX?

• JSX (JavaScript XML) — это синтаксическое расширение для JavaScript  
• Позволяет писать декларативную разметку, похожую на HTML, внутри JS-кода.  
• На этапе сборки (например, с помощью Babel) JSX компилируется в вызовы React.createElement()  

Правила:  
• Атрибуты используют camelCase (className, onClick)  
• Можно встраивать JavaScript-выражения через { }  
• Теги обязательно закрывающиеся  

### Что такое компоненты. Какие типы компонентов вы знаете?

 Это независимый, переиспользуемый блок пользовательского интерфейса со своей структурой (разметка), стилями и логикой.

**Основные типы компонентов:**

 1.  **По синтаксису:**  
    • **Функциональные компоненты** — современный стандарт, используют хуки.  
      `const Button = () => <button>Click</button>;`  
    • **Классовые компоненты** — legacy-подход, основанный на ES6-классах.  
      `class Button extends React.Component { ... }`  

2.  **По наличию внутреннего состояния:**  
    • **Stateful (с состоянием)** — управляют своими данными через `useState`, `useReducer` или `this.state`.  
    • **Stateless (без состояния, «чистые»)** — получают данные только через `props` и всегда отрисовывают одинаковый результат для одинаковых пропсов.  

3.  **По источнику данных для форм и элементов:**  
    • **Управляемые (Controlled)** — значение элемента (например, `input`) полностью контролируется React-состоянием и передаётся через `props`. Любое изменение идёт через обработчик (например, `onChange`).  
    • **Неуправляемые (Uncontrolled)** — значение элемента хранится в самом DOM, а React получает к нему доступ через `ref` (например, при отправке формы).  

### Разница между классовыми и функциональными компонентами?

• И классовые, и функциональные компоненты могут иметь состояние, используют разный синтаксис: классы — this.state/setState(), функции — хук useState(),

• с 2019 года React рекомендует функциональные компоненты как стандарт благодаря более простой работе с побочными эффектами, переиспользуемой логикой и отсутствию проблем с this.

### Что такое props и как они передаются в компоненты?

Это объект с любым типом данных, который передаётся только дочернему компоненту через атрибуты в JSX.  

Ключевые особенности:  
• Можно типизировать через PropTypes или TS.  
• Всегда иммутабельны — изменять props внутри компонента нельзя.  
• children существует только при передаче содержимого между тегами компонента.  

### Что такое состояние (state) и чем оно отличается от props?

• **state** — это локальные изменяемые данные компонента, управляемые им самим. Обновление state вызывает ререндер компонента. State может «всплывать».  
• **props** — это внешние неизменяемые данные, передаваемые от родителя. Изменение props у родителя — ререндер дочернего компонента.  


### Жизненный цикл компонента?

Содержит три фазы:  
• монтирование (добавление в DOM);  
• обновление (из-за изменений props/state);  
• размонтирование (удаление из DOM);  

В классовых компонентах React вызывает специальные методы на каждой фазе (componentDidMount, componentDidUpdate, componentWillUnmount).  

В функциональных компонентах реализуют через хук useEffect с разными зависимостями и cleanup-функцией.

useEffect:  
- `useEffect(() => {}, [])` — только монтирование.  
- `useEffect(() => {})` — монтирование + каждое обновление.  
- `useEffect(() => {}, [deps])` — монтирование + обновление при изменении deps.  
-  `useEffect(() => { return () => {} })` Функция очистки (cleanup) выполняется перед удалением компонента (размонтирование) или перед следующим выполнением эффекта. Аналог componentWillUnmount.

###  Что такое key. Зачем они нужны при рендере списков?

Уникальный идентификатор, сопоставляет элементы списков между рендерами, позволяя обновлять только изменённые элементы.

## Хуки (Hooks).

### Что такое хуки. Какие основные правила их использования?

Хуки — это специальные функции, которые дают функциональным компонентам доступ к состоянию, побочным эффектам, контексту и другим возможностям React.

Основные правила:
1. Вызывать только на верхнем уровне компонента (не в условиях/циклах).
2. Вызывать только из React-компонентов или кастомных хуков.
3. Сохранять одинаковый порядок вызовов при каждом рендере — это позволяет React корректно сопоставлять состояние между рендерами.


### Расскажите про useState?

`useState` — это хук, который объявляет переменную состояния в функциональном компоненте.

Принимает начальное значение и возвращает массив из двух элементов:
- текущее значение состояния;
- функция-сеттер для его обновления.

При вызове функции компонент перерисовывается с новым значением.

React использует `Object.is()` для сравнения нового значения с предыдущим. Если они равны — ререндер не происходит.

### Расскажите про useEffect?

• Это хук, который позволяет выполнять побочные эффекты (работа с DOM, запросы данных, подписки).  

• Принимает функцию-эффект и опциональный массив зависимостей.  

• Функция может возвращать cleanup-функцию для отмены подписок, таймеров и других ресурсов.  

useEffect:
- `useEffect(() => {}, [])` — только монтирование.  
- `useEffect(() => {})` — монтирование + каждое обновление.  
- `useEffect(() => {}, [deps])` — монтирование + обновление при изменении deps.  
-  `useEffect(() => { return () => {} })` Функция очистки выполняется перед удалением компонента или перед следующим выполнением эффекта.

### Расскажите про useContext?

• Это хук, который принимает объект контекста (созданный `React.createContext`) и возвращает текущее значение этого контекста.

• Позволяет любому компоненту в дереве ниже Provider получить доступ к данным, минуя промежуточные компоненты.

• При изменении значения в Provider все компоненты, использующие этот контекст через `useContext`, автоматически перерисовываются.

**Важное уточнение:**   

• `useContext` подписывает компонент на изменения контекста.

• Можно оптимизировать через `React.memo` или разделение контекстов.

### Расскажите про useRef?

Это хук, который возвращает изменяемый `ref`-объект с единственным свойством `.current`, инициализируемым переданным аргументом.

Служит двум целям:
1. Получение прямого доступа к DOM-узлу через атрибут `ref`.
2. Хранение мутабельных значений, которые должны сохраняться между рендерами, но не требуют ререндера при изменении.

Можно хранить:
- DOM-элементы.
- Таймеры, интервалы.
- Предыдущие значения состояния.
- Любые мутабельные данные.

Особенности работы:
- Инициализация происходит только при первом рендере.
- Значение сохраняется на всё время жизни компонента.
- Не помещается в очередь обновлений
- Можно читать сразу после присваивания
- Изменение происходит синхронно и не влияет на жизненный цикл компонента.

### Расскажите про useMemo?

Это хук, который принимает функцию-вычислитель и массив зависимостей, сохраняет (мемоизирует) результат вычисления между рендерами и возвращает это же значение при последующих рендерах, пока зависимости не изменились.

Предотвращает излишние повторные вычисления, оптимизируя производительность, особенно для дорогих операций или когда стабильность ссылки важна для оптимизации дочерних компонентов.

Особенности работы:
- Функция-вычислитель выполняется во время рендера (не после, как `useEffect`).
- Возвращает значение, а не функцию (в отличие от `useCallback`).
- Гарантирует ссылочную постоянность при неизменных зависимостях.

Когда использовать:
- Тяжёлые вычисления (сортировка, фильтрация, математические операции).
- Создание объектов/массивов, которые передаются как зависимости других хуков.
- Стабилизация ссылок на значения для оптимизации дочерних компонентов.

### Расскажите про useCallback?

Это хук, который принимает функцию и массив зависимостей, и возвращает мемоизированную версию этой функции.

Функция пересоздаётся только при изменении какой-либо зависимости в массиве. Это гарантирует сохранение ссылочной идентичности функции между рендерами, что необходимо для предотвращения лишних ререндеров оптимизированных дочерних компонентов (обёрнутых в `React.memo`) и предотвращения ненужных срабатываний эффектов, зависящих от функций.

Когда использовать:
- Функции как зависимости других хуков (`useEffect`, `useMemo`).
- Функции как props для оптимизированных дочерних компонентов (`React.memo`).
- Функции в контексте для предотвращения лишних ререндеров.

Правила применения:
- Не используйте `useCallback` просто так — только если есть конкретная проблема с ререндерами.
- Всегда включайте все зависимости, которые функция использует.
- Для функций, изменяющих состояние, используйте функциональную форму `setState`.
- Рассмотрите вынос функции вообще из компонента, если она не зависит от его состояния.

### Что такое dependency array?

Это опциональный второй параметр хуков `useEffect`, `useMemo` и `useCallback`, содержащий значения, от которых зависит выполнение хука.

React сравнивает каждое значение из массива с предыдущим рендером с помощью `Object.is()`, и если хотя бы одно изменилось — хук выполняется заново.

Три режима работы:
- `[a, b]` (с зависимостями) — выполняется при изменении `a` или `b`.
- `[]` (пустой массив) — хук зависит от ничего и выполнится один раз при монтировании.
- Без массива — хук зависит от всего и выполняется при каждом рендере.

Поведение для разных хуков:
- `useEffect` — перезапускает эффект.
- `useMemo` — пересчитывает значение.
- `useCallback` — пересоздаёт функцию.

### В чем разница между useMemo и useCallback?

`useMemo` мемоизирует результат вычисления функции и возвращает это значение.

`useCallback` мемоизирует саму функцию, возвращая ту же самую ссылку на функцию между рендерами при неизменных зависимостях.

Оба хука принимают массив зависимостей и пересчитываются только при их изменении.

Что возвращают:
- `useMemo` → значение (число, строка, объект, массив).
- `useCallback` → функцию (ссылка на функцию).

### Расскажите про React.memo?

Это компонент высшего порядка, который оборачивает функциональный компонент, кэширует результат его рендера и перерисовывает его только при изменении props.

По умолчанию используется поверхностное сравнение props, но можно передать кастомную функцию сравнения вторым аргументом.

Это аналог `PureComponent` для функциональных компонентов, оптимизирующий производительность за счёт предотвращения излишних ререндеров.

Когда использовать `React.memo`:
- Чистые компоненты (одинаковые props → одинаковый вывод).
- Частые ререндеры родительского компонента.
- Тяжёлые компоненты с сложной логикой рендера.
- Компоненты, получающие стабильные props.

Когда НЕ использовать:
- Компоненты, которые всегда получают разные props.
- Компоненты с лёгким рендером (оптимизация может быть дороже).
- Компоненты, которые должны обновляться часто.

Ограничения и подводные камни:
- Не работает с хуками состояния: `useState`, `useReducer` внутри компонента всё равно вызывают ререндеры.
- Только props: Контекст вызывает ререндер независимо от `React.memo`.
- Ссылочная стабильность: Для объектов/функций в props нужны `useMemo`/`useCallback`.

### Как работает useRef и для чего он используется (кроме доступа к DOM)?

`useRef` — это хук, который создаёт изменяемый объект `.current`, сохраняющийся между рендерами без вызова ререндера; используется для доступа к DOM и хранения мутабельных значений (таймеры, флаги, кэши).

**Как работает `useRef`**

1. Создаёт объект с единственным свойством `.current`
2. Инициализируется значением из аргумента только при первом рендере
3. Сохраняет объект между всеми рендерами компонента
4. Изменения `.current` происходят синхронно (мгновенно)
5. Изменения `.current` НЕ вызывают повторный рендер компонента
6. React автоматически управляет `.current` при использовании с DOM-элементами через атрибут `ref`
7. Значение сохраняется всё время жизни компонента
8. Работает по принципу «мутабельного кармана» — можно менять без ограничений
9. Не отслеживается React-ом для ререндеров (в отличие от `useState`)
10. Подчиняется общим правилам хуков: вызывается только на верхнем уровне

### Как создать собственный хук?

Это JS-функция, название которой начинается с `use`, которая может вызывать другие хуки React и инкапсулирует логику для переиспользования в разных компонентах.

Основные правила создания:
- Имя начинается с `use` (например, `useLocalStorage`, `useFetch`).
- Может вызывать другие хуки (`useState`, `useEffect`, и т.д.).
- Возвращает значение, массив или объект с данными и функциями.
- Изолированное состояние — каждый вызов создаёт независимое состояние.

## Управление состоянием и данные.