## 1. Общие вопросы

[Как React вносит изменения в Real DOM](#как-react-вносит-изменения-в-real-dom)  
[Объясните разницу между Real DOM и Virtual DOM](#объясните-разницу-между-real-dom-и-virtual-dom)  
[Что такое JSX](#что-такое-jsx)  
[Что такое React. Каковы его основные преимущества и чем он отличается от других фреймворков (например, Angular, Vue)](#что-такое-react)  
[Что такое Virtual DOM и как он работает ](#что-такое-virtual-dom)  

### Что такое React?

• Это JS библиотека для декларативной сборки переиспользуемых UI-компонентов на основе JSX  
• Использует Virtual DOM для обновления интерфейса  
• Отвечает только за отрисовку UI
• Позволяет гибко выбирать остальные инструменты  

### Что такое Virtual DOM?

• Упрощенная JS-копия реального DOM  
• Вычисляет разницу между состояниями интерфейса (diffing), и определяет минимальный набор изменений  
• Пакетно обновляет только изменившиеся элементы страницы.  

### Объясните разницу между Real DOM и Virtual DOM

**Real DOM:**  
• **Медленный:** Прямые манипуляции с DOM  
• **Обновляет весь узел:** При изменении одного атрибута, перерисовывается весь элемент и его дети  
• **Тяжёлый:** Сложная структура с тысячами свойств и методов  
• **Синхронный:** Изменения применяются сразу, может блокировать основной поток  

**Virtual DOM:**  
• **Быстрый:** Работает с упрощенными JS-объектами в памяти  
• **Обновляет точечно:** Сравнивает состояния (diffing) и изменяет только нужные элементы  
• **Лёгкий:** Упрощённое представление DOM-структуры (только теги, атрибуты, содержимое)  
• **Оптимизированный:** Изменения накапливаются и применяются пачкой за один проход  


### Как React вносит изменения в Real DOM?

1. **Создание Virtual DOM**  
   При каждом изменении состояния React создаёт новый Virtual DOM — упрощённый JS-объект, представляющий структуру UI.

2. **Сравнение (Diffing Algorithm)**  
   React сравнивает новый Virtual DOM с предыдущим (реконсиляция) и вычисляет **минимальный набор изменений** — что именно добавить, удалить или обновить.

3. **Пакетное обновление (Batching)**  
   Все вычисленные изменения собираются в "пакет" и применяются к Real DOM **за одну синхронную операцию**, а не по отдельности.

4. **Оптимизированное обновление Real DOM**  
   React использует оптимальные браузерные API (`appendChild`, `removeChild`, `setAttribute`) только для тех узлов, которые действительно изменились.

### Что такое JSX?

• JSX (JavaScript XML) — это синтаксическое расширение для JavaScript  
• Позволяет писать декларативную разметку, похожую на HTML, внутри JS-кода.  
• На этапе сборки (например, с помощью Babel) JSX компилируется в вызовы React.createElement()  

Правила:  
• Атрибуты используют camelCase (className, onClick)  
• Можно встраивать JavaScript-выражения через { }  
• Теги обязательно закрывающиеся  

## 2. Компоненты

[Что такое компоненты. Какие типы компонентов вы знаете](#что-такое-компоненты-какие-типы-компонентов-вы-знаете)  
[Разница между классовыми и функциональными компонентами](#разница-между-классовыми-и-функциональными-компонентами)  
[Что такое props и как они передаются в компоненты](#что-такое-props-и-как-они-передаются-в-компоненты)  
[Что такое состояние (state) и чем оно отличается от props](#что-такое-состояние-state-и-чем-оно-отличается-от-props)  
[Жизненный цикл компонента](#жизненный-цикл-компонента)  
[Что такое key. Зачем они нужны при рендере списков](#что-такое-key-зачем-они-нужны-при-рендере-списков)  
### Что такое компоненты. Какие типы компонентов вы знаете?

 Это независимый, переиспользуемый блок пользовательского интерфейса со своей структурой (разметка), стилями и логикой.

**Основные типы компонентов:**

 1.  **По синтаксису:**  
    • **Функциональные компоненты** — современный стандарт, используют хуки.  
      `const Button = () => <button>Click</button>;`  
    • **Классовые компоненты** — legacy-подход, основанный на ES6-классах.  
      `class Button extends React.Component { ... }`  

2.  **По наличию внутреннего состояния:**  
    • **Stateful (с состоянием)** — управляют своими данными через `useState`, `useReducer` или `this.state`.  
    • **Stateless (без состояния, «чистые»)** — получают данные только через `props` и всегда отрисовывают одинаковый результат для одинаковых пропсов.  

3.  **По источнику данных для форм и элементов:**  
    • **Управляемые (Controlled)** — значение элемента (например, `input`) полностью контролируется React-состоянием и передаётся через `props`. Любое изменение идёт через обработчик (например, `onChange`).  
    • **Неуправляемые (Uncontrolled)** — значение элемента хранится в самом DOM, а React получает к нему доступ через `ref` (например, при отправке формы).  

### Разница между классовыми и функциональными компонентами?

• И классовые, и функциональные компоненты могут иметь состояние, используют разный синтаксис: классы — this.state/setState(), функции — хук useState(),

• с 2019 года React рекомендует функциональные компоненты как стандарт благодаря более простой работе с побочными эффектами, переиспользуемой логикой и отсутствию проблем с this.

### Что такое props и как они передаются в компоненты?

Это объект с любым типом данных, который передаётся только дочернему компоненту через атрибуты в JSX.  

Ключевые особенности:  
• Можно типизировать через PropTypes или TS.  
• Всегда иммутабельны — изменять props внутри компонента нельзя.  
• children существует только при передаче содержимого между тегами компонента.  

### Что такое состояние (state) и чем оно отличается от props?

• **state** — это локальные изменяемые данные компонента, управляемые им самим. Обновление state вызывает ререндер компонента. State может «всплывать».  
• **props** — это внешние неизменяемые данные, передаваемые от родителя. Изменение props у родителя — ререндер дочернего компонента.  


### Жизненный цикл компонента?

Содержит три фазы:  
• монтирование (добавление в DOM);  
• обновление (из-за изменений props/state);  
• размонтирование (удаление из DOM);  

В классовых компонентах React вызывает специальные методы на каждой фазе (componentDidMount, componentDidUpdate, componentWillUnmount).  

В функциональных компонентах реализуют через хук useEffect с разными зависимостями и cleanup-функцией.

useEffect:  
- `useEffect(() => {}, [])` — только монтирование.  
- `useEffect(() => {})` — монтирование + каждое обновление.  
- `useEffect(() => {}, [deps])` — монтирование + обновление при изменении deps.  
-  `useEffect(() => { return () => {} })` Функция очистки (cleanup) выполняется перед удалением компонента (размонтирование) или перед следующим выполнением эффекта. Аналог componentWillUnmount.

###  Что такое key. Зачем они нужны при рендере списков?

Уникальный идентификатор, сопоставляет элементы списков между рендерами, позволяя обновлять только изменённые элементы.

## 3. Хуки (Hooks).

[Что такое хуки. Какие основные правила их использования](#что-такое-хуки-какие-основные-правила-их-использования)  
[Расскажите про useState](#расскажите-про-usestate)  
[Расскажите про useEffect](#расскажите-про-useeffect)  
[Расскажите про useContext](#расскажите-про-usecontext)  
[Расскажите про useRef](#расскажите-про-useref)  
[Расскажите про useMemo](#расскажите-про-usememo)  
[Расскажите про useCallback](#расскажите-про-usecallback)  
[Что такое dependency array](#что-такое-dependency-array)   
[Как работает useRef и для чего он используется (кроме доступа к DOM)](#как-работает-useref-и-для-чего-он-используется-кроме-доступа-к-dom)  
[Как создать собственный хук](#как-создать-собственный-хук)  

### Что такое хуки. Какие основные правила их использования?

Хуки — это специальные функции, которые дают функциональным компонентам доступ к состоянию, побочным эффектам, контексту и другим возможностям React.

Основные правила:
1. Вызывать только на верхнем уровне компонента (не в условиях/циклах).
2. Вызывать только из React-компонентов или кастомных хуков.
3. Сохранять одинаковый порядок вызовов при каждом рендере — это позволяет React корректно сопоставлять состояние между рендерами.


### Расскажите про useState?

`useState` — это хук, который объявляет переменную состояния в функциональном компоненте.

Принимает начальное значение и возвращает массив из двух элементов:
- текущее значение состояния;
- функция-сеттер для его обновления.

При вызове функции компонент перерисовывается с новым значением.

React использует `Object.is()` для сравнения нового значения с предыдущим. Если они равны — ререндер не происходит.

### Расскажите про useEffect?

• Это хук, который позволяет выполнять побочные эффекты (работа с DOM, запросы данных, подписки).  

• Принимает функцию-эффект и опциональный массив зависимостей.  

• Функция может возвращать cleanup-функцию для отмены подписок, таймеров и других ресурсов.  

useEffect:
- `useEffect(() => {}, [])` — только монтирование.  
- `useEffect(() => {})` — монтирование + каждое обновление.  
- `useEffect(() => {}, [deps])` — монтирование + обновление при изменении deps.  
-  `useEffect(() => { return () => {} })` Функция очистки выполняется перед удалением компонента или перед следующим выполнением эффекта.

### Расскажите про useContext?

• Это хук, который принимает объект контекста (созданный `React.createContext`) и возвращает текущее значение этого контекста.

• Позволяет любому компоненту в дереве ниже Provider получить доступ к данным, минуя промежуточные компоненты.

• При изменении значения в Provider все компоненты, использующие этот контекст через `useContext`, автоматически перерисовываются.

**Важное уточнение:**   

• `useContext` подписывает компонент на изменения контекста.

• Можно оптимизировать через `React.memo` или разделение контекстов.

### Расскажите про useRef?

Это хук, который возвращает изменяемый `ref`-объект с единственным свойством `.current`, инициализируемым переданным аргументом.

Служит двум целям:
1. Получение прямого доступа к DOM-узлу через атрибут `ref`.
2. Хранение мутабельных значений, которые должны сохраняться между рендерами, но не требуют ререндера при изменении.

Можно хранить:
- DOM-элементы.
- Таймеры, интервалы.
- Предыдущие значения состояния.
- Любые мутабельные данные.

Особенности работы:
- Инициализация происходит только при первом рендере.
- Значение сохраняется на всё время жизни компонента.
- Не помещается в очередь обновлений
- Можно читать сразу после присваивания
- Изменение происходит синхронно и не влияет на жизненный цикл компонента.

### Расскажите про useMemo?

Это хук, который принимает функцию-вычислитель и массив зависимостей, сохраняет (мемоизирует) результат вычисления между рендерами и возвращает это же значение при последующих рендерах, пока зависимости не изменились.

Предотвращает излишние повторные вычисления, оптимизируя производительность, особенно для дорогих операций или когда стабильность ссылки важна для оптимизации дочерних компонентов.

Особенности работы:
- Функция-вычислитель выполняется во время рендера (не после, как `useEffect`).
- Возвращает значение, а не функцию (в отличие от `useCallback`).
- Гарантирует ссылочную постоянность при неизменных зависимостях.

Когда использовать:
- Тяжёлые вычисления (сортировка, фильтрация, математические операции).
- Создание объектов/массивов, которые передаются как зависимости других хуков.
- Стабилизация ссылок на значения для оптимизации дочерних компонентов.

### Расскажите про useCallback?

Это хук, который принимает функцию и массив зависимостей, и возвращает мемоизированную версию этой функции.

Функция пересоздаётся только при изменении какой-либо зависимости в массиве. Это гарантирует сохранение ссылочной идентичности функции между рендерами, что необходимо для предотвращения лишних ререндеров оптимизированных дочерних компонентов (обёрнутых в `React.memo`) и предотвращения ненужных срабатываний эффектов, зависящих от функций.

Когда использовать:
- Функции как зависимости других хуков (`useEffect`, `useMemo`).
- Функции как props для оптимизированных дочерних компонентов (`React.memo`).
- Функции в контексте для предотвращения лишних ререндеров.

Правила применения:
- Не используйте `useCallback` просто так — только если есть конкретная проблема с ререндерами.
- Всегда включайте все зависимости, которые функция использует.
- Для функций, изменяющих состояние, используйте функциональную форму `setState`.
- Рассмотрите вынос функции вообще из компонента, если она не зависит от его состояния.

### Что такое dependency array?

Это опциональный второй параметр хуков `useEffect`, `useMemo` и `useCallback`, содержащий значения, от которых зависит выполнение хука.

React сравнивает каждое значение из массива с предыдущим рендером с помощью `Object.is()`, и если хотя бы одно изменилось — хук выполняется заново.

Три режима работы:
- `[a, b]` (с зависимостями) — выполняется при изменении `a` или `b`.
- `[]` (пустой массив) — хук зависит от ничего и выполнится один раз при монтировании.
- Без массива — хук зависит от всего и выполняется при каждом рендере.

Поведение для разных хуков:
- `useEffect` — перезапускает эффект.
- `useMemo` — пересчитывает значение.
- `useCallback` — пересоздаёт функцию.

### Как работает useRef и для чего он используется (кроме доступа к DOM)?

`useRef` — это хук, который создаёт изменяемый объект `.current`, сохраняющийся между рендерами без вызова ререндера; используется для доступа к DOM и хранения мутабельных значений (таймеры, флаги, кэши).

**Как работает `useRef`**

1. Создаёт объект с единственным свойством `.current`
2. Инициализируется значением из аргумента только при первом рендере
3. Сохраняет объект между всеми рендерами компонента
4. Изменения `.current` происходят синхронно (мгновенно)
5. Изменения `.current` НЕ вызывают повторный рендер компонента
6. React автоматически управляет `.current` при использовании с DOM-элементами через атрибут `ref`
7. Значение сохраняется всё время жизни компонента
8. Работает по принципу «мутабельного кармана» — можно менять без ограничений
9. Не отслеживается React-ом для ререндеров (в отличие от `useState`)
10. Подчиняется общим правилам хуков: вызывается только на верхнем уровне

### Как создать собственный хук?

Это JS-функция, название которой начинается с `use`, которая может вызывать другие хуки React и инкапсулирует логику для переиспользования в разных компонентах.

Основные правила создания:
- Имя начинается с `use` (например, `useLocalStorage`, `useFetch`).
- Может вызывать другие хуки (`useState`, `useEffect`, и т.д.).
- Возвращает значение, массив или объект с данными и функциями.
- Изолированное состояние — каждый вызов создаёт независимое состояние.




## 7. Оптимизация

[В чем разница между useMemo и useCallback](#в-чем-разница-между-usememo-и-usecallback)   
[Расскажите про React memo](#расскажите-про-react-memo)   

### В чем разница между useMemo и useCallback?

`useMemo` мемоизирует результат вычисления функции и возвращает это значение.

`useCallback` мемоизирует саму функцию, возвращая ту же самую ссылку на функцию между рендерами при неизменных зависимостях.

Оба хука принимают массив зависимостей и пересчитываются только при их изменении.

Что возвращают:
- `useMemo` → значение (число, строка, объект, массив).
- `useCallback` → функцию (ссылка на функцию).

### Расскажите про React memo?

Это компонент высшего порядка, который оборачивает функциональный компонент, кэширует результат его рендера и перерисовывает его только при изменении props.

По умолчанию используется поверхностное сравнение props, но можно передать кастомную функцию сравнения вторым аргументом.

Это аналог `PureComponent` для функциональных компонентов, оптимизирующий производительность за счёт предотвращения излишних ререндеров.

Когда использовать `React.memo`:
- Чистые компоненты (одинаковые props → одинаковый вывод).
- Частые ререндеры родительского компонента.
- Тяжёлые компоненты с сложной логикой рендера.
- Компоненты, получающие стабильные props.

Когда НЕ использовать:
- Компоненты, которые всегда получают разные props.
- Компоненты с лёгким рендером (оптимизация может быть дороже).
- Компоненты, которые должны обновляться часто.

Ограничения и подводные камни:
- Не работает с хуками состояния: `useState`, `useReducer` внутри компонента всё равно вызывают ререндеры.
- Только props: Контекст вызывает ререндер независимо от `React.memo`.
- Ссылочная стабильность: Для объектов/функций в props нужны `useMemo`/`useCallback`.














## 4. Управление состоянием и данные.
[Что такое состояние (state) в React и как его создать](#)  
[Почему нельзя изменять состояние напрямую](#почему-нельзя-изменять-состояние-напрямую)  
[Что происходит при вызове setState или сеттера из useState?](#что-происходит-при-вызове-setstate-или-сеттера-из-usestate)
[Что такое состояние (state) в React и для чего оно нужно](#что-такое-состояние-state-в-react-и-для-чего-оно-нужно)  
[Чем state отличается от props](#чем-state-отличается-от-props)  
[Как создать state в функциональном компоненте](#как-создать-state-в-функциональном-компоненте)  
[Почему нельзя изменять state напрямую и как его правильно обновлять](#почему-нельзя-изменять-state-напрямую-и-как-его-правильно-обновлять)  
[Что делает `setState` в классовых компонентах](#что-делает-setstate-в-классовых-компонентах)  
[Что делает сеттер из `useState` (например, `setValue`)](#что-делает-сеттер-из-usestate-например-setvalue)  
[Может ли state быть объектом или массивом](#может-ли-state-быть-объектом-или-массивом)  
[Что произойдет, если вызвать `setState` несколько раз подряд](#что-произойдет-если-вызвать-setstate-несколько-раз-подряд)  
[Как инициализировать state на основе props в функциональном компоненте](#как-инициализировать-state-на-основе-props-в-функциональном-компоненте)  


### Что такое состояние (state) в React и как его создать?

Состояние в React — это изменяемые данные, принадлежащие компоненту, которые определяют его поведение и отображение.

В функциональных компонентах состояние создаётся с помощью хука `useState` или `useReducer`, в классовых — через `this.state` в конструкторе.

При обновлении состояния React автоматически перерисовывает компонент и, при необходимости, его дочерние элементы.

Состояние изолировано для каждого экземпляра компонента и является единственным источником истины для данных, меняющихся в течение жизненного цикла компонента.

### Почему нельзя изменять состояние напрямую?

React полагается на иммутабельные обновления для определения изменений состояния. Прямое мутирование не вызывает ререндер, потому что React сравнивает объекты по ссылкам, а мутация не создаёт новую ссылку.

Функции `setState` и сеттеры из `useState` уведомляют React о необходимости обновления, планируют ререндер и гарантируют корректную работу concurrent-режима, хуков жизненного цикла и оптимизаций вроде `React.memo` и `PureComponent`.

Механизм обнаружения изменений:
- React использует сравнение по ссылкам (shallow comparison).
- `setState()` или сеттер из `useState` помечают компонент как «грязный».
- React планирует ререндер помеченных компонентов.
- При рендере сравниваются ссылки на старые и новые объекты.

Исключения и нюансы:
- Ссылочные типы внутри `useRef`.
- Мутации в `useEffect` после копирования.

**Concurrent-режим** — это архитектурное обновление React 18+, которое делает рендеринг прерываемым.

React может приостанавливать вычисления для рендера, чтобы браузер мог обрабатывать пользовательские события, а затем возобновлять рендеринг.

Ключевые API:
- `startTransition` для помечания неблокирующих обновлений состояния.
- `useTransition` для отслеживания таких переходов.
- `useDeferredValue` для отложенного получения значения.

Это позволяет приоритизировать отзывчивость интерфейса над фоновыми вычислениями.

### Что происходит при вызове setState или сеттера из useState?

При вызове `setState` или сеттера `useState`:

- React помещает обновление в очередь.
- Обновления батчатся (группируются) для оптимизации производительности.
- В React 18 батчинг работает везде, в React 17 — только в обработчиках React-событий.
- Состояние меняется асинхронно — новое значение недоступно сразу после вызова.
- Для последовательных обновлений нужно использовать функциональную форму: `setCount(prev => prev + 1)`.
- Компонент будет перерендерен с новым состоянием после обработки всех обновлений в очереди.


### Что такое состояние (state) в React и для чего оно нужно?

**State** — это внутренние изменяемые данные компонента, которые определяют его поведение и то, **как он отображается в UI** в конкретный момент времени.

Ключевые характеристики state:

* **Локален** — принадлежит конкретному экземпляру компонента.
* **Изменяем** — обновляется только через `setState` / сеттер из `useState`.
* **Реактивен** — изменение state **планирует повторный рендер** компонента.
* **Источник истины** — UI должен быть функцией от `state` и `props`.

Как создаётся состояние:

* **В функциональных компонентах** — с помощью хуков:

  * `useState` — для простого локального состояния.
  * `useReducer` — для более сложной логики обновлений.
* **В классовых компонентах** — через `this.state` в конструкторе.

Как React работает со state:

* При обновлении state React **не меняет DOM напрямую**.
* Компонент помечается как «грязный».
* React выполняет повторный рендер, сравнивает Virtual DOM и обновляет Real DOM минимально возможным образом.

Когда используют state:

* Данные **меняются со временем** (ввод пользователя, загрузка данных, переключатели).
* Изменение данных должно **отразиться в интерфейсе**.
* Данные принадлежат компоненту, а не приходят извне.

Когда state не нужен:

* Если данные не меняются → обычная переменная.
* Если данные приходят от родителя → `props`.
* Если данные глобальные → Context / внешнее хранилище.

### Чем state отличается от props?

> **State — внутренние изменяемые данные компонента, props — внешние неизменяемые данные, переданные от родителя.**

* **Владелец данных:**

  * State — управляется самим компонентом.
  * Props — управляются родителем, передаются вниз.

* **Изменяемость:**

  * State обновляется через `setState` / сеттер `useState`.
  * Props нельзя менять внутри компонента.

* **Ререндер:**

  * Изменение state → повторный рендер компонента.
  * Изменение props у родителя → ререндер дочернего компонента.

* **Использование:**

  * State — локальные динамические данные (счётчики, формы, переключатели).
  * Props — передача данных и функций дочерним компонентам.

* **Дополнительно:**

  * State может «всплывать» через **lifting state up** для синхронизации между компонентами.
  * Props помогают делать компонент **переиспользуемым и управляемым извне**.


Отлично, идём дальше.

---

### Как создать state в функциональном компоненте?

> **В функциональном компоненте state создаётся с помощью хука `useState`, который возвращает текущее значение и функцию для его обновления.**

#### Подробности:

* **Синтаксис:**

```javascript
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // count — значение, setCount — функция обновления
  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}
```

* **Как работает:**

  * `useState(initialValue)` — инициализирует state с начальным значением.
  * Возвращает массив `[value, setter]`.
  * Вызов setter → планирует повторный рендер компонента с новым значением.

* **Особенности:**

  * Начальное значение можно задать функцией: `useState(() => computeInitialValue())` — вычисление будет выполнено **только один раз при первом рендере**.
  * Можно хранить любые типы: числа, строки, объекты, массивы.
  * Объекты и массивы нужно обновлять **иммутабельно**, создавая новый объект/массив при каждом обновлении.

* **Проверка на ререндер:**

  * React использует `Object.is()` для сравнения нового и старого значения state.
  * Если значение не изменилось → повторный рендер не происходит.

### Почему нельзя изменять state напрямую и как его правильно обновлять?

> **Нельзя мутировать state напрямую, потому что React не увидит изменения; нужно использовать `setState` (классы) или сеттер из `useState` (функциональные компоненты), чтобы триггерить ререндер.**

#### Подробности:

* **Что происходит при прямой мутации:**

  ```javascript
  // ❌ НЕПРАВИЛЬНО
  state.count = 5;
  ```

  * React не планирует повторный рендер.
  * Virtual DOM не обновится → UI не изменится.
  * Нарушается иммутабельность, что может сломать оптимизации (`React.memo`, batching, concurrent mode).

* **Правильное обновление:**

  * **Функциональные компоненты:**

    ```javascript
    setCount(5);              // простое значение
    setCount(prev => prev + 1); // функциональная форма для последовательных обновлений
    ```
  * **Классовые компоненты:**

    ```javascript
    this.setState({ count: 5 });
    ```

* **Почему это важно:**

  1. React отслеживает изменения по **ссылкам** (shallow comparison).
  2. Только через сеттер создаётся **новый объект/значение**, React помечает компонент как «грязный».
  3. Это гарантирует корректный **асинхронный ререндер** и совместимость с Concurrent Mode (React 18+).

* **Особенности работы с объектами/массивами:**

  ```javascript
  // ❌ мутация
  setState({ user: { ...state.user, name: 'Alex' } }); // новый объект — правильно
  ```

  * Всегда создаём новый объект/массив, чтобы React увидел изменение по ссылке.

* **Функциональная форма setter-а (`prev => newValue`)**

  * Необходима, если обновления зависят от предыдущего состояния.
  * Гарантирует корректность при нескольких подряд вызовах `setState`.

### Что делает `setState` в классовых компонентах?

> **`setState` обновляет состояние компонента и планирует его повторный рендер, при этом React объединяет несколько вызовов для оптимизации производительности.**

#### Подробности:

* **Синтаксис:**

```javascript
this.setState({ count: 5 });
```

или функционально:

```javascript
this.setState(prevState => ({ count: prevState.count + 1 }));
```

* **Как работает:**

  1. React помещает обновление в **очередь** (асинхронно).
  2. Несколько вызовов `setState` могут **объединяться (batching)** для одного рендера.
  3. После обновления state React вызывает **повторный рендер** компонента.
  4. Virtual DOM сравнивает старый и новый рендер → Real DOM обновляется минимально.

* **Особенности функциональной формы:**

  * Если новое состояние зависит от старого, используем функцию:

    ```javascript
    this.setState(prevState => ({ count: prevState.count + 1 }));
    ```
  * Гарантирует корректное обновление при нескольких последовательных вызовах.

* **Примечание:**

  * `setState` **не обновляет сразу** — новое значение недоступно мгновенно после вызова.
  * Для сложных объектов или массивов используем **иммутабельные копии**, чтобы React увидел изменение.

* **Concurrent Mode (React 18+):**

  * Позволяет React приостанавливать обновление и объединять несколько `setState` для оптимизации производительности.

### Что делает сеттер из `useState` (например, `setValue`)?


> **Сеттер из `useState` обновляет состояние функционального компонента и вызывает его повторный рендер с новым значением.**

#### Подробности:

* **Синтаксис:**

```javascript
const [count, setCount] = useState(0);

// обновление состояния
setCount(5); // новое значение
setCount(prev => prev + 1); // функциональная форма
```

* **Как работает:**

  1. Вызов сеттера помещает новое состояние в **очередь обновлений**.
  2. React планирует **повторный рендер компонента**.
  3. Virtual DOM сравнивает новый рендер с предыдущим → обновляется только изменившаяся часть Real DOM.

* **Функциональная форма:**

  * Используется, когда новое состояние зависит от предыдущего:

    ```javascript
    setCount(prevCount => prevCount + 1);
    ```
  * Гарантирует правильное обновление при нескольких последовательных вызовах.

* **Особенности:**

  * **Асинхронное обновление:** новое значение недоступно сразу после вызова.
  * **Иммутабельность:** для объектов и массивов всегда создаём новый объект/массив:

    ```javascript
    setUser(prev => ({ ...prev, name: 'Alex' }));
    ```
  * React использует `Object.is()` для проверки, изменилось ли значение. Если нет — повторный рендер не происходит.

* **Batching:**

  * Несколько вызовов сеттера в одном событии объединяются, чтобы ререндер был один, повышая производительность.



> **Сеттер из `useState` обновляет состояние функционального компонента и вызывает его повторный рендер с новым значением.**

#### Подробности:

* **Синтаксис:**

```javascript
const [count, setCount] = useState(0);

// обновление состояния
setCount(5); // новое значение
setCount(prev => prev + 1); // функциональная форма
```

* **Как работает:**

  1. Вызов сеттера помещает новое состояние в **очередь обновлений**.
  2. React планирует **повторный рендер компонента**.
  3. Virtual DOM сравнивает новый рендер с предыдущим → обновляется только изменившаяся часть Real DOM.

* **Функциональная форма:**

  * Используется, когда новое состояние зависит от предыдущего:

    ```javascript
    setCount(prevCount => prevCount + 1);
    ```
  * Гарантирует правильное обновление при нескольких последовательных вызовах.

* **Особенности:**

  * **Асинхронное обновление:** новое значение недоступно сразу после вызова.
  * **Иммутабельность:** для объектов и массивов всегда создаём новый объект/массив:

    ```javascript
    setUser(prev => ({ ...prev, name: 'Alex' }));
    ```
  * React использует `Object.is()` для проверки, изменилось ли значение. Если нет — повторный рендер не происходит.

* **Batching:**

  * Несколько вызовов сеттера в одном событии объединяются, чтобы ререндер был один, повышая производительность.

### Может ли state быть объектом или массивом?

**Шпаргалка:**

> Да, state может быть объектом или массивом, но обновлять их нужно **иммутабельно**, создавая новый объект или массив.

#### Подробности:

* **Пример с объектом:**

```javascript
const [user, setUser] = useState({ name: 'Alex', age: 38 });

// правильное обновление
setUser(prev => ({ ...prev, age: 39 }));
```

* **Пример с массивом:**

```javascript
const [items, setItems] = useState([1, 2, 3]);

// добавление элемента
setItems(prev => [...prev, 4]);
```

* **Почему нельзя мутировать напрямую:**

```javascript
// ❌ НЕПРАВИЛЬНО
user.age = 39;  // React не увидит изменения → UI не обновится
```

* **Особенности:**

  * React использует **сравнение по ссылкам** (shallow comparison), поэтому важно создавать **новый объект/массив** при каждом обновлении.
  * Для сложного состояния с вложенными объектами часто используют **функциональную форму сеттера**: `setState(prev => ...)`.
  * Иммутабельные обновления совместимы с **Concurrent Mode**, **React.memo** и другими оптимизациями.

* **Рекомендации:**

  * Для глубоких изменений использовать копирование через spread (`...`) или `immer`.
  * Стараться держать state **плоским**, чтобы проще отслеживать изменения.



### Может ли state быть объектом или массивом?

**Шпаргалка:**

> Да, state может быть объектом или массивом, но обновлять их нужно **иммутабельно**, создавая новый объект или массив.

#### Подробности:

* **Пример с объектом:**

```javascript
const [user, setUser] = useState({ name: 'Alex', age: 38 });

// правильное обновление
setUser(prev => ({ ...prev, age: 39 }));
```

* **Пример с массивом:**

```javascript
const [items, setItems] = useState([1, 2, 3]);

// добавление элемента
setItems(prev => [...prev, 4]);
```

* **Почему нельзя мутировать напрямую:**

```javascript
// ❌ НЕПРАВИЛЬНО
user.age = 39;  // React не увидит изменения → UI не обновится
```

* **Особенности:**

  * React использует **сравнение по ссылкам** (shallow comparison), поэтому важно создавать **новый объект/массив** при каждом обновлении.
  * Для сложного состояния с вложенными объектами часто используют **функциональную форму сеттера**: `setState(prev => ...)`.
  * Иммутабельные обновления совместимы с **Concurrent Mode**, **React.memo** и другими оптимизациями.

* **Рекомендации:**

  * Для глубоких изменений использовать копирование через spread (`...`) или `immer`.
  * Стараться держать state **плоским**, чтобы проще отслеживать изменения.


### Что произойдет, если вызвать `setState` несколько раз подряд?

**Шпаргалка:**

> В классовых и функциональных компонентах React объединяет (batching) несколько вызовов `setState` в один ререндер для оптимизации; если нужно учитывать предыдущее состояние, используют функциональную форму сеттера.

#### Подробности:

* **Batching обновлений:**

  * Несколько вызовов `setState` в одном событии **объединяются**, и компонент ререндерится только один раз.
  * Экономит ресурсы и ускоряет рендер.

* **Функциональная форма для последовательных обновлений:**

```javascript
// функциональные компоненты
setCount(prev => prev + 1);
setCount(prev => prev + 1); // оба вызова учтут предыдущее значение

// классовые компоненты
this.setState(prev => ({ count: prev.count + 1 }));
this.setState(prev => ({ count: prev.count + 1 }));
```

* Без функциональной формы при объектном setState/сеттере могут возникнуть **гонки состояния**, когда второе обновление перезапишет первое.

* **Асинхронность:**

  * Новое значение state **не доступно сразу** после вызова `setState`.
  * React планирует обновление на следующий рендер.

* **React 18+:**

  * Batching теперь работает **во всех случаях**, включая таймеры и промисы (раньше — только в обработчиках событий React).

* **Практический вывод:**

  * Всегда использовать **функциональную форму**, если новое состояние зависит от предыдущего.
  * Batch-обновления повышают производительность интерфейса.

### Как инициализировать state на основе props в функциональном компоненте?

**Шпаргалка:**

> Инициализацию state на основе props делают через `useState(() => initialValue)`, чтобы вычисление происходило один раз при первом рендере.

#### Подробности:

* **Пример:**

```javascript
function Counter({ initialCount }) {
  const [count, setCount] = useState(() => initialCount);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

* **Особенности:**

  * Использование функции `() => initialValue` **откладывает вычисление** до первого рендера, экономя ресурсы, если вычисление сложное.
  * Простое `useState(initialCount)` тоже работает, но функция полезна для дорогостоящих вычислений.

* **Важно:**

  * После первого рендера state **не будет автоматически обновляться**, если props изменились.
  * Если нужно реагировать на изменения props, используют `useEffect`:

```javascript
useEffect(() => {
  setCount(initialCount);
}, [initialCount]);
```

* **Рекомендации:**

  * State и props должны быть **разделены**, чтобы компонент был предсказуемым.
  * State хранит **локальные изменения**, props — внешний источник данных.
  * Никогда не мутируйте props напрямую; всегда создавайте локальный state, если нужно их изменять внутри компонента.